import groovy.transform.Field

@Field
final String pipelineConfig = '''
{
    "ports":{
        "app":{
            "postgres-master":1000,            
            "postgres_lt-master":1001,            
            "mssql-master":1100,           
            "mssql_lt-master":1101,           
            "oracle-master":1200,            
            "oracle_lt-master":1201            
        },
        "db":{
            "postgres-master":1010,            
            "postgres_lt-master":1011,            
            "mssql-master":1110,           
            "mssql_lt-master":1111,           
            "oracle-master":1210,
            "oracle_lt-master":1211
        },
        "front":{
            "postgres-master":1020,            
            "postgres_lt-master":1021,            
            "mssql-master":1120,           
            "mssql_lt-master":1121,           
            "oracle-master":1220,
            "oracle_lt-master":1221
        }
    }
}
'''

pipeline {
    agent { label 'built-in' }

    tools {
        maven 'M3'
        jdk 'JDK21'
        nodejs 'node'
    }

    environment {
        REGISTRY = '192.168.0.81:32000'
        GIT_PROJECT_NAME = 'Supportly'
        E2E_DOCKER_HOST = '192.168.0.81'
        E2E_DOCKER_HOST_URL = 'http://192.168.0.81:'
    }

    parameters {
        booleanParam(name: 'E2E_TESTS', defaultValue: true, description: 'Czy stworzyƒá dockery?')
        booleanParam(name: 'E2E_TESTS_RUN', defaultValue: false, description: 'Czy uruchomiƒá testy E2E?')
        booleanParam(name: 'CLEANUP_DOCKER', defaultValue: true, description: 'Czy czy≈õciƒá kontenery, obrazy i wolumeny Docker po testach E2E?')
        booleanParam(name: 'DEPLOY_TO_KUBE', defaultValue: false, description: 'Czy wdro≈ºyƒá do MicroK8s?')
        string(name: 'NUMER_PROBY', defaultValue: '1', description: 'Wpisz numer pr√≥by')
    }

    options {
        timestamps()
        timeout(time: 5, unit: 'HOURS')
        buildDiscarder(logRotator(numToKeepStr: '30'))
        disableConcurrentBuilds()
        skipDefaultCheckout()
    }
    stages {
        stage('Checkout') {
            steps {
                echo ">>>[Pobieranie najnowszych zmian]<<<"
                checkoutSources()
            }
        }

//        stage('Build & Test') {
//            steps {
//                script {
//
//                    parallel('Build & Test Backend': {
////                        dir('supportly-backend') {
////                            echo ">>>[TESTY BACKENDU]<<<"
////                            sh "mvn verify -Dspring.profiles.active=${env.PROFILE.replace('_lt', '')} -Dmaven.test.failure.ignore=true"
////                            junit 'target/surefire-reports/*.xml'
////                            echo ">>>[BUDOWANIE BACKENDU]<<<"
////                            sh "mvn clean package spring-boot:repackage -P${env.PROFILE.replace('_lt', '')} -Dspring.profiles.active=${env.PROFILE.replace('_lt', '')}  -DskipTests"
////                        }
//                        dir('supportly-backend') {
//                            echo ">>>[TESTY BACKENDU]<<<"
//
//                            parallel {
//                                stage('Testy Czƒô≈õƒá 1') {
//                                    steps {
//                                        // Uruchamia testy, kt√≥rych nazwa zaczyna siƒô na litery A-M
//                                        sh "mvn verify -Dtest=[A-M]* -Dspring.profiles.active=${env.PROFILE.replace('_lt', '')} -Dmaven.test.failure.ignore=true"
//                                    }
//                                }
//                                stage('Testy Czƒô≈õƒá 2') {
//                                    steps {
//                                        // Uruchamia testy, kt√≥rych nazwa zaczyna siƒô na litery N-Z
//                                        sh "mvn verify -Dtest=[N-Z]* -Dspring.profiles.active=${env.PROFILE.replace('_lt', '')} -Dmaven.test.failure.ignore=true"
//                                    }
//                                }
//                            }
//
//                            // Raportowanie po zako≈Ñczeniu obu wƒÖtk√≥w
//                            junit 'target/surefire-reports/*.xml'
//
//                            echo ">>>[BUDOWANIE BACKENDU]<<<"
//                            // Budowanie wykonujemy raz, po testach
//                            sh "mvn clean package spring-boot:repackage -P${env.PROFILE.replace('_lt', '')} -Dspring.profiles.active=${env.PROFILE.replace('_lt', '')} -DskipTests"
//                        }
//                    },
//                            'Build & Test Frontend': {
//                                dir('supportly-frontend') {
////                                    replaceInFile('http://localhost:8080', "http://${env.PROJECT_NAME}-backend-${env.PROFILE}-1:${env.PORT_BACKEND}", "src/assets/config.json")
//                                    echo ">>>[BUDOWANIE FRONTENDU]<<<"
//                                    sh "yes | ng version"
//                                    sh script: "npm install --force", label: "npm install"
//                                    sh script: "ng build --output-path=../conf/frontend/supportly-frontend", label: "ng build"
//                                }
//                            })
//
////                    replaceInFile('localhost', '192.168.0.81', "conf/docker-compose-${env.PROFILE}.yml")
////                    replaceInFile('PORT_DB', env.PORT_DB, "conf/docker-compose-${env.PROFILE}.yml")
//                    replaceInFile('PORT_DB', env.PORT_DB, "conf/docker-compose-${env.PROFILE}.yml")
//                    replaceInFile('PORT_BACKEND', env.PORT_BACKEND, "conf/docker-compose-${env.PROFILE}.yml")
//                    replaceInFile('latest', env.BUILDTAG, "conf/docker-compose-${env.PROFILE}.yml")
//                    replaceInFile('latest', env.BUILDTAG, "conf/kube/k8s-deployment.yaml")
//                    replaceInFile('PORT_FRONTEND', env.PORT_FRONT, "conf/docker-compose-${env.PROFILE}.yml")
////                    replaceInFile('URL_BACKEND', "${env.PROJECT_NAME}-backend-${env.PROFILE}-1/${env.PORT_BACKEND}/", "src/assets/nginx.conf")
//                    replaceInFile('http://localhost:8080', "http://${env.E2E_DOCKER_HOST}:${env.PORT_BACKEND}", "conf/frontend/supportly-frontend/browser/assets/config.json")
//                    replaceInFile('1009', env.PORT_DB, 'conf/backend/backend.env')
//                    replaceInFile('localhost', '192.168.0.81', 'conf/backend/backend.env')
//                    replaceInFile('API', "http://192.168.0.81:${env.PORT_FRONT}", 'conf/backend/backend.env')
//                    replaceInFile('default', "${env.PROFILE.replace('_lt', '')}", 'conf/backend/Dockerfile')
//
//                    sh "cat conf/docker-compose-${env.PROFILE}.yml"
//                    sh 'cat conf/backend/backend.env'
//
//                    stash name: 'supportly', includes: 'conf/**', useDefaultExcludes: false
//                    stash name: 'supportly-e2e', includes: 'supportly-e2e/**', useDefaultExcludes: false
//
//                }
//            }
//        }
        stage('Build & Test') {
            steps {
                script {
                    parallel('Build & Test Backend': {
//                        dir('supportly-backend') {
//                            echo ">>>[KOMPILACJA WSTƒòPNA (Aby przygotowaƒá klasy dla obu wƒÖtk√≥w)]<<<"
//                            // 1. Czy≈õcimy i kompilujemy kod oraz testy RAZ.
//                            // Dziƒôki temu w bloku parallel Maven korzysta ju≈º z gotowych plik√≥w .class
//                            sh "mvn clean test-compile -P${env.PROFILE.replace('_lt', '')} -Dspring.profiles.active=${env.PROFILE.replace('_lt', '')}"
//
//                            echo ">>>[TESTY BACKENDU (R√ìWNOLEG≈ÅE: UNIT vs IT)]<<<"
//
//                            // 2. Uruchamiamy testy r√≥wnolegle.
//                            // WA≈ªNE: Nie u≈ºywamy tu 'clean' ani 'compile', tylko same cele testowe.
//                            parallel(
//                                    "Unit Tests": {
//                                        echo "Start: Testy Jednostkowe (*Test.java)"
//                                        // surefire:test -> Uruchamia tylko testy jednostkowe
//                                        sh "mvn surefire:test -P${env.PROFILE.replace('_lt', '')} -Dspring.profiles.active=${env.PROFILE.replace('_lt', '')} -Dmaven.test.failure.ignore=true"
//                                    },
//                                    "Integration Tests": {
//                                        echo "Start: Testy Integracyjne (*IT.java)"
//                                        // failsafe:integration-test -> Uruchamia tylko testy integracyjne (dziƒôki Twojej naprawie w pom.xml)
//                                        sh "mvn failsafe:integration-test -P${env.PROFILE.replace('_lt', '')} -Dspring.profiles.active=${env.PROFILE.replace('_lt', '')} -Dmaven.test.failure.ignore=true"
//                                    }
//                            )
//
//                            // 3. Zbieramy raporty (Surefire generuje je w surefire-reports, Failsafe w failsafe-reports)
//                            junit '**/target/*-reports/*.xml'
//
//                            echo ">>>[BUDOWANIE PACZKI JAR]<<<"
//                            // 4. Pakujemy aplikacjƒô. U≈ºywamy -DskipTests, bo testy przesz≈Çy ju≈º wy≈ºej.
//                            // Faza package automatycznie zawiera w sobie budowanie, wiƒôc nie musimy kompilowaƒá od nowa.
//                            sh "mvn package -DskipTests -P${env.PROFILE.replace('_lt', '')} -Dspring.profiles.active=${env.PROFILE.replace('_lt', '')}"
//                        }

                        dir('supportly-backend') {
                            echo ">>>[URUCHAMIANIE TEST√ìW I BUDOWANIE (SEKWENCYJNIE)]<<<"

                            // Zastosowa≈Çem tu trik z '&&'.
                            // KROK 1: 'mvn clean test failsafe:integration-test' -> Uruchamia Unity i IT.
                            // KROK 2: '&& mvn package -DskipTests' -> Je≈õli testy przejdƒÖ, buduje JAR (pomijajƒÖc testy, bo ju≈º przesz≈Çy).

                            sh "mvn clean test failsafe:integration-test -P${env.PROFILE.replace('_lt', '')} -Dspring.profiles.active=${env.PROFILE.replace('_lt', '')} -Dmaven.test.failure.ignore=true && mvn package -DskipTests -P${env.PROFILE.replace('_lt', '')} -Dspring.profiles.active=${env.PROFILE.replace('_lt', '')}"

                            // Zbieramy wyniki
                            junit '**/target/*-reports/*.xml'
                        }
                    },
                            'Build & Test Frontend': {
                                dir('supportly-frontend') {
                                    echo ">>>[BUDOWANIE FRONTENDU]<<<"
                                    sh "yes | ng version"
                                    sh script: "npm install --force", label: "npm install"
                                    sh script: "ng build --output-path=../conf/frontend/supportly-frontend", label: "ng build"
                                }
                            })

                    // --- Reszta Twojego skryptu bez zmian ---
                    replaceInFile('PORT_DB', env.PORT_DB, "conf/docker-compose-${env.PROFILE}.yml")
                    replaceInFile('PORT_BACKEND', env.PORT_BACKEND, "conf/docker-compose-${env.PROFILE}.yml")
                    replaceInFile('latest', env.BUILDTAG, "conf/docker-compose-${env.PROFILE}.yml")
                    replaceInFile('latest', env.BUILDTAG, "conf/kube/k8s-deployment.yaml")
                    replaceInFile('PORT_FRONTEND', env.PORT_FRONT, "conf/docker-compose-${env.PROFILE}.yml")
                    replaceInFile('http://localhost:8080', "http://${env.E2E_DOCKER_HOST}:${env.PORT_BACKEND}", "conf/frontend/supportly-frontend/browser/assets/config.json")
                    replaceInFile('1009', env.PORT_DB, 'conf/backend/backend.env')
                    replaceInFile('localhost', '192.168.0.81', 'conf/backend/backend.env')
                    replaceInFile('API', "http://192.168.0.81:${env.PORT_FRONT}", 'conf/backend/backend.env')
                    replaceInFile('default', "${env.PROFILE.replace('_lt', '')}", 'conf/backend/Dockerfile')

                    sh "cat conf/docker-compose-${env.PROFILE}.yml"
                    sh 'cat conf/backend/backend.env'

                    stash name: 'supportly', includes: 'conf/**', useDefaultExcludes: false
                    stash name: 'supportly-e2e', includes: 'supportly-e2e/**', useDefaultExcludes: false
                }
            }
        }
        stage('Build & Push Images') {
            when {
                expression { params.E2E_TESTS }
            }
            agent { label 'docker-agent' }
            steps {
                script {
                    unstash 'supportly'

                    echo ">>> Building and pushing Docker images to local registry..."
                    dir('conf') {

                        sh "cat docker-compose-${env.PROFILE}.yml"
                        // ... (reszta Twoich debug√≥w) ...

                        // 1. ZBUDUJ (To masz) - tworzy "ciasto" na dysku
                        sh "docker compose -f docker-compose-${env.PROFILE}.yml build --no-cache"
                        if (params.DEPLOY_TO_KUBE) {
                            // 2. WY≈öLIJ (Tego brakowa≈Ço!) - wysy≈Ça "ciasto" do sklepu (Rejestru 192.168.0.81)
                            sh "docker compose -f docker-compose-${env.PROFILE}.yml push"
                        }
                    }
                }
            }
        }

        stage('DeployE2E') {
            when {
                expression { params.E2E_TESTS }
            }
            agent { label 'docker-agent' }

            steps {
                script {
                    echo ">>> Deploying docker-compose on remote host ..."

                    unstash 'supportly'
                    if (containsSubstring(env.PROFILE, "_lt")) {
                        dockerStop("${env.PROJECT_NAME}-database-${env.PROFILE}-1")

                        startContainerSafely("${env.PROJECT_NAME}-database-${env.PROFILE}-1")
                        if (env.PROFILE == "postgres_lt") {
                            runSql()
                        }

                        if (env.PROFILE == "mssql_lt") {
                            runSqlMssql()
                        }

                        if (env.PROFILE == "oracle_lt") {
                            waitForOracle("${env.PROJECT_NAME}-database-${env.PROFILE}-1")

                            runClearScriptOracle("${env.PROJECT_NAME}-database-${env.PROFILE}-1")

                        }

//                        waitForOracle("${env.PROJECT_NAME}-database-${env.PROFILE}-1")
                    }

                    dir('conf') {

                        echo ">>> U≈ºywam taga obrazu: ${buildTag}"

                        echo ">>> Project name dla Compose: ${env.PROJECT_NAME}"

                        echo ">>> Usuwam istniejƒÖce kontenery i sieci..."
                        sh """
                        docker compose -f docker-compose-${env.PROFILE}.yml -p ${env.PROJECT_NAME} down --remove-orphans  -v || true
                        """
//                        docker compose -f docker-compose-${env.PROFILE}.yml -p ${env.PROJECT_NAME} down --remove-orphans -v || true

                        echo ">>> Uruchamiam docker-compose lokalnie (na agencie)..."
                        sh """
                        docker compose -f docker-compose-${env.PROFILE}.yml -p ${env.PROJECT_NAME} up -d
                            """

                        echo ">>> Sprawdzam, czy kontenery dzia≈ÇajƒÖ poprawnie..."
                        waitForContainers(["${env.PROJECT_NAME}-backend-${env.PROFILE}-1",
                                           "${env.PROJECT_NAME}-database-${env.PROFILE}-1"] as List<String>)

                    }
                }
            }
        }


//        stage('E2E') {
//            when {
//                expression { params.E2E_TESTS && params.E2E_TESTS_RUN }
//            }
//            steps {
//                script {
//                    echo ">>> Running Selenium E2E tests..."
//
//                    unstash 'supportly-e2e'
//
//                    def databaseUrl = ""
//
//                    if (env.PROFILE.replace('_lt', '') == "postgres") {
//                        databaseUrl = "jdbc:postgresql://192.168.0.81:${env.PORT_DB}/postgres"
//                    }
//
//                    if (env.PROFILE.replace('_lt', '') == "mssql") {
//                        databaseUrl = """jdbc:sqlserver://192.168.0.81:${env.PORT_DB};databaseName=supportly;encrypt=false"""
//                    }
//
//                    if (env.PROFILE.replace('_lt', '') == "oracle") {
//                        databaseUrl = "jdbc:postgresql://192.168.0.81:${env.PORT_DB}/postgres"
//                    }
//
//                    echo "${env.E2E_DOCKER_HOST_URL}${env.PORT_FRONT}"
//                    echo "${databaseUrl}"
//
//
//                    dir('supportly-e2e') {
//                        // Je≈õli testy siƒô nie powiodƒÖ, stage bƒôdzie czerwony,
//                        // ale pipeline p√≥jdzie dalej i raporty siƒô opublikujƒÖ.
//                        catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
//                            sh """
//                        export BASE_URL=${env.E2E_DOCKER_HOST_URL}${env.PORT_FRONT}
//                        export BASE_URL_DATABASE=${databaseUrl}
//                        export PROFILE=${env.PROFILE}
//                        mvn clean test
//                    """
//                        }
//                    }
//                }
//            }
//        }

        stage('E2E') {
            when {
                expression { params.E2E_TESTS && params.E2E_TESTS_RUN }
            }
            steps {
                script {
                    echo ">>> Running Selenium E2E tests..."

                    unstash 'supportly-e2e'

                    // --- Twoja logika wyboru bazy danych ---
                    def databaseUrl = ""
                    if (env.PROFILE.replace('_lt', '') == "postgres") {
                        databaseUrl = "jdbc:postgresql://192.168.0.81:${env.PORT_DB}/postgres"
                    } else if (env.PROFILE.replace('_lt', '') == "mssql") {
                        databaseUrl = """jdbc:sqlserver://192.168.0.81:${env.PORT_DB};databaseName=supportly;encrypt=false"""
                    } else if (env.PROFILE.replace('_lt', '') == "oracle") {
                        databaseUrl = "jdbc:postgresql://192.168.0.81:${env.PORT_DB}/postgres"
                    }

                    echo "URL: ${env.E2E_DOCKER_HOST_URL}${env.PORT_FRONT}"
                    echo "DB: ${databaseUrl}"

                    dir('supportly-e2e') {
                        // Definiujemy wsp√≥lne zmienne ≈õrodowiskowe, ≈ºeby nie kopiowaƒá ich 2 razy
                        // U≈ºywamy potr√≥jnego cudzys≈Çowu dla czytelno≈õci bloku
                        def e2eEnvVars = """
                    export BASE_URL=${env.E2E_DOCKER_HOST_URL}${env.PORT_FRONT}
                    export BASE_URL_DATABASE=${databaseUrl}
                    export PROFILE=${env.PROFILE}
                """

                        catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                            // Najpierw kompilujemy kod RAZ (sekwencyjnie), ≈ºeby wƒÖtki nie bi≈Çy siƒô o folder target
                            sh "mvn clean test-compile -DskipTests"

                            parallel(
                                    "E2E Group 1": {
                                        echo "Start: Agreement, Employee"
                                        // Wstrzykujemy zmienne i odpalamy pierwsze dwa testy
                                        sh """
                                ${e2eEnvVars}
                                mvn surefire:test -Dtest=AgreementTest,EmployeeTest
                            """
                                    },
                                    "E2E Group 2": {
                                        echo "Start: HomePage, Login, Task"
                                        // Wstrzykujemy zmienne i odpalamy resztƒô
                                        sh """
                                ${e2eEnvVars}
                                mvn surefire:test -Dtest=HomePageTest,LoginTest,TaskTest
                            """
                                    }
                            )
                        }
                    }
                }
            }
        }
        stage('Cleanup Docker') {
            when {
                expression { params.E2E_TESTS && params.CLEANUP_DOCKER }
            }
            agent { label 'docker-agent' }

            steps {
                script {
                    echo ">>> Cleanup docker containers, images and volumes"

                    unstash 'supportly'


                    echo ">>> Using project name: ${env.PROJECT_NAME} for cleanup"

                    if (containsSubstring(env.PROFILE, "_lt")) {
                        dockerStop("${env.PROJECT_NAME}-database-${env.PROFILE}-1")
                    }


//                docker compose -f conf/docker-compose-${env.PROFILE}-lt.yml -p ${env.PROJECT_NAME} down --volumes --remove-orphans
                    sh """
                # Usuwamy tylko kontenery i sieci dla tego project name
                docker compose -f conf/docker-compose-${env.PROFILE}.yml -p ${env.PROJECT_NAME}  down --volumes 

                # Opcjonalnie czyszczenie nieu≈ºywanych obraz√≥w i wolumen√≥w
                docker image prune -f
                docker volume prune -f
            """
                }
            }
        }
//        stage('Deploy to kube') {
//            when {
//                expression { params.DEPLOY_TO_KUBE }
//            }
//            steps {
//                dir('conf') {
//                    script {
//                        // 1. Sprawdzanie gotowo≈õci API serwera MicroK8s
//                        // U≈ºywamy """ aby m√≥c escape'owaƒá znaki $
//                        def checkHealthz = remoteMicrok8s("""
//                    for i in {1..10}; do
//                        echo ">>> Pr√≥ba \$i: sprawdzanie /healthz..."
//                        microk8s kubectl get --raw=/healthz && break
//                        echo ">>> API jeszcze nie gotowe, czekam 5s..."
//                        sleep 5
//                    done
//                """)
//
//                        // 2. Komenda wdra≈ºania
//                        def deployCommand = """
//                    echo ">>> Wdra≈ºanie do zdalnego MicroK8s ..."
//                    cat kube/k8s-deployment.yaml | ssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no jenkins@192.168.0.81 'microk8s kubectl apply --validate=false -f -'
//                """
//
//                        // 3. Weryfikacja wdro≈ºenia (POPRAWIONA)
//                        // U≈ºywamy """ (cudzys≈Ç√≥w podw√≥jny), aby w ≈õrodku u≈ºyƒá ' (pojedynczego) dla awk.
//                        // Wszystkie zmienne bashowe ($TIMEOUT, $NOT_READY, $2) muszƒÖ mieƒá przed sobƒÖ backslash (\$).
//                        def verifyDeployment = remoteMicrok8s("""
//                    echo ">>> Weryfikacja wdro≈ºenia (maks. 5 minut)..."
//
//                    TIMEOUT=60   # 60 x 5s = 300s = 5 minut
//                    INTERVAL=5
//
//                    for i in \$(seq 1 \$TIMEOUT); do
//                        # ZMIANA: U≈ºywamy tr i cut zamiast awk.
//                        # grep -v "1/1" -> odrzuca gotowe pody
//                        # tr -s ' '     -> usuwa nadmiarowe spacje (formatowanie tabeli)
//                        # cut -d ' ' -f 1 -> bierze pierwszƒÖ kolumnƒô (nazwƒô)
//
//                        NOT_READY=\$(microk8s kubectl get pods -n my-app --no-headers | grep -v "1/1" | tr -s ' ' | cut -d ' ' -f 1)
//
//                        if [ -z "\$NOT_READY" ]; then
//                            echo ">>> Wszystkie pody osiƒÖgnƒô≈Çy stan Ready."
//                            microk8s kubectl get pods -n my-app
//                            exit 0
//                        fi
//
//                        echo ">>> Pody jeszcze nie gotowe: \$NOT_READY (\$i/\$TIMEOUT)"
//                        sleep \$INTERVAL
//                    done
//
//                    echo "Nie wszystkie pody osiƒÖgnƒô≈Çy stan Ready w czasie 5 minut."
//                    microk8s kubectl get pods -n my-app
//                    echo ">>> Debug (describe):"
//                    microk8s kubectl describe pods -n my-app
//                    exit 1
//                """)
//
//                        // Wykonanie ca≈Ço≈õci
//                        sh """
//                    echo ">>> Sprawdzanie gotowo≈õci MicroK8s na ho≈õcie zdalnym..."
//                    ${checkHealthz}
//
//                    ${deployCommand}
//
//                    echo ">>> Sprawdzanie, czy wdro≈ºenie siƒô powiod≈Ço..."
//                    ${verifyDeployment}
//                """
//                    }
//                }
//            }
//        }
        stage('Deploy to kube') {
            when {
                expression { params.DEPLOY_TO_KUBE }
            }
            steps {
                dir('conf') {
                    script {
                        // --- KROK 1: Check Healthz (Przeniesione do Groovy) ---
                        echo ">>> [KROK 1] Sprawdzanie gotowo≈õci API MicroK8s..."
                        int maxHealthRetries = 10
                        boolean apiReady = false

                        for (int i = 1; i <= maxHealthRetries; i++) {
                            // returnStatus: true sprawia, ≈ºe sh nie wywali b≈Çƒôdu pipeline'u, tylko zwr√≥ci kod wyj≈õcia (0 = OK, inne = b≈ÇƒÖd)
                            // Wysy≈Çamy prostƒÖ komendƒô bez pƒôtli i bez 'break'
                            int exitCode = sh(script: remoteMicrok8s("microk8s kubectl get --raw=/healthz"), returnStatus: true)

                            if (exitCode == 0) {
                                echo ">>> (Pr√≥ba ${i}/${maxHealthRetries}) API jest gotowe!"
                                apiReady = true
                                break
                            } else {
                                echo ">>> (Pr√≥ba ${i}/${maxHealthRetries}) API nie odpowiada, czekam 5s..."
                                sleep 5
                            }
                        }

                        if (!apiReady) {
                            error "‚ùå B≈ÅƒÑD: API MicroK8s nie wsta≈Ço po ${maxHealthRetries} pr√≥bach."
                        }

                        // --- KROK 2: Deploy ---
                        echo ">>> [KROK 2] Wdra≈ºanie manifest√≥w..."
                        // Tutaj wysy≈Çamy jednƒÖ, konkretnƒÖ komendƒô
                        def deployCmd = "cat kube/k8s-deployment.yaml | ssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no jenkins@192.168.0.81 'microk8s kubectl apply --validate=false -f -'"
                        sh deployCmd

                        // --- KROK 3: Weryfikacja (Logika Groovy) ---
                        echo ">>> [KROK 3] Weryfikacja statusu pod√≥w..."

                        int maxPodRetries = 60
                        int podDelay = 5
                        boolean podsReady = false

                        for (int i = 1; i <= maxPodRetries; i++) {
                            // Wersja BEZ tr/cut - najbardziej niezawodna przez SSH
                            // Zwraca pe≈Çne linie pod√≥w, kt√≥re nie sƒÖ gotowe (np. "backend 0/1 Error ...")
                            def checkCmdString = remoteMicrok8s("microk8s kubectl get pods -n my-app --no-headers | grep -v '1/1' || true")

                            def notReadyPods = sh(script: checkCmdString, returnStdout: true).trim()

                            if (notReadyPods.isEmpty()) {
                                echo ">>> (Pr√≥ba ${i}/${maxPodRetries}) SUKCES: Wszystkie pody sƒÖ Ready (1/1)."
                                podsReady = true
                                break
                            } else {
                                // Teraz w logach zobaczysz pe≈Çny status, co pomo≈ºe zrozumieƒá dlaczego pod nie wstaje
                                echo ">>> (Pr√≥ba ${i}/${maxPodRetries}) Pody jeszcze nie gotowe:\n${notReadyPods}"
                                sleep podDelay
                            }
                        }

                        if (!podsReady) {
                            echo "‚ùå B≈ÅƒÑD: Timeout weryfikacji pod√≥w."
                            def debugInfo = sh(script: remoteMicrok8s("microk8s kubectl describe pods -n my-app"), returnStdout: true)
                            echo ">>> DEBUG INFO:\n${debugInfo}"
                            error "Wdro≈ºenie nieudane: pody nie wsta≈Çy w zadanym czasie."
                        }
                    }
                }
            }
        }


    }

    post {
        always {
            echo "Finished"
            script {
                // Bezpieczna konwersja na boolean i sprawdzenie warunku
                if (params.E2E_TESTS_RUN.toBoolean()) {
                    junit 'supportly-e2e/target/surefire-reports/*.xml'
                }
            }
            echo "Build duration: ${currentBuild.durationString}"
        }
        success {
            echo "Finished success"
        }
        unstable {
            echo "Finished unstable"
        }
        failure {
            echo "Finished with error"
        }
        aborted {
            echo "Build aborted"
        }
    }
}

void replaceInFile(String pattern, String replacement, String filePath) {
    sh "sed -i 's+${pattern}+${replacement}+g' ${filePath}"
}

static def remoteMicrok8s(String command) {
    return """
        ssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no jenkins@192.168.0.81 '${command}'
    """
}

def isContainerHealthy(String containerName) {
    def status = sh(script: "docker inspect --format='{{.State.Status}}' ${containerName}", returnStdout: true).trim()
    def health = sh(script: "docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}no_healthcheck{{end}}' ${containerName}", returnStdout: true).trim()

    echo "Kontener ${containerName}: status=${status}, health=${health}"

    if (status != 'running') {
        echo "Kontener ${containerName} NIE dzia≈Ça (status: ${status})"
        return false
    }
    if (health != 'healthy' && health != 'no_healthcheck') {
        echo "Kontener ${containerName} ma z≈Çy stan zdrowia: ${health}"
        return false
    }
    echo "Kontener ${containerName} dzia≈Ça poprawnie i jest zdrowy."
    return true
}

def waitForContainers(List<String> containers, int maxWaitSeconds = 120, int intervalSeconds = 10) {
    int elapsed = 0
    while (elapsed < maxWaitSeconds) {
        echo "Sprawdzam kontenery, pr√≥ba po ${elapsed} sekundach..."
        boolean allHealthy = true
        for (container in containers) {
            if (!isContainerHealthy(container)) {
                allHealthy = false
            }
        }
        if (allHealthy) {
            echo "Wszystkie kontenery dzia≈ÇajƒÖ poprawnie."
            return true
        }
        echo "Kontenery jeszcze nie sƒÖ gotowe, czekam ${intervalSeconds} sekund..."
        sleep(intervalSeconds)
        elapsed += intervalSeconds
    }
    error("Nie wszystkie kontenery dzia≈Ça≈Çy prawid≈Çowo po ${maxWaitSeconds} sekundach!")
}

void checkoutSources() {

    // Rozpoznawanie ga≈Çƒôzi i profilu
    env.PIPELINE_TYPE = get_branch_name(['master', 'develop', 'PullRequest'])
    env.LT = false
    env.PROFILE = getProfile(env.JOB_NAME)

    println("Build profile: ${env.PROFILE}, branch: ${env.PIPELINE_TYPE}")
    println("JOB_NAME: ${JOB_NAME}")

    if ("PullRequest".equals(env.PIPELINE_TYPE)) {
        checkout_pull_request(env.GIT_PROJECT_NAME)
        env.MERGE_REQUEST_BUILD = true
    } else {
        checkoutRepo(env.GIT_PROJECT_NAME, env.PIPELINE_TYPE)
    }

    env.BUILDTAG = sh(script: "date +%Y%m%d-%H%M", returnStdout: true).trim()

    prepareNames(env.PIPELINE_TYPE)
}

void checkoutRepo(String project, String branch) {
    println("[checkout] ${project} -> ${branch}")

    def scmVars = checkout([$class                           : 'GitSCM',
                            branches                         : [[name: "${branch}"]],
                            doGenerateSubmoduleConfigurations: false,
                            extensions                       : [[$class: 'CloneOption', noTags: true]],
                            userRemoteConfigs                : [[credentialsId: 'Github',
                                                                 url          : "https://github.com/AWieczorek00/${project}.git"

                                                                ]]])

    env.GIT_COMMIT = scmVars.GIT_COMMIT
}

void prepareNames(String branch) {

    echo "Prepare environment variables | branch: ${branch}"


    def props = readJSON text: pipelineConfig
    def name = "${env.PROFILE}-${branch}"
    echo "Nazwa proffilu parametru ${name}"

    def wsSuffix = getWorkspaceSuffix()
    env.PROJECT_NAME = "supportly-${wsSuffix}"
    def projectName = "supportly-${wsSuffix}"


    env.PORT_BACKEND = props.ports.app[name]
    env.PORT_DB = props.ports.db[name]
    env.PORT_FRONT = props.ports.front[name]

    echo "PORT_BACKEND: ${env.PORT_BACKEND}"
    echo "PORT_DB: ${env.PORT_DB}"
    echo "PORT_FRONT: ${env.PORT_FRONT}"


}


def checkout_pull_request(String project) {
    echo "Pobieranie najnowszego PR z repozytorium ${project}"

    // Pobranie ostatniego otwartego PR z GitHub API
    def response = httpRequest(url: "https://api.github.com/repos/AWieczorek00/${project}/pulls?state=open&sort=updated&direction=desc&per_page=1",
            httpMode: 'GET',
            acceptType: 'APPLICATION_JSON')

    def prs = readJSON text: response.content
    if (prs.size() == 0) {
        error "Nie znaleziono ≈ºadnych otwartych PR w repozytorium ${project}"
    }

    def pr = prs[0]
    def prId = pr.number.toString()
    def sourceBranch = pr.head.ref
    def targetBranch = pr.base.ref

    echo "Checkout latest PR #${prId}: ${sourceBranch} -> ${targetBranch}"

    // Fetch i checkout brancha PR
    checkout([$class           : 'GitSCM',
              branches         : [[name: "refs/remotes/origin/${sourceBranch}"]],
              extensions       : [[$class: 'CloneOption', noTags: true]],
              userRemoteConfigs: [[url          : "https://github.com/AWieczorek00/${project}.git",
                                   credentialsId: 'Github',
                                   refspec      : "+refs/heads/${sourceBranch}:refs/remotes/origin/${sourceBranch}"]]])

    // Merge do branch docelowego
    sh """
        git fetch origin ${targetBranch}:${targetBranch}
        git merge ${targetBranch} --no-ff -m "Merge ${targetBranch} into ${sourceBranch}"
    """
}

value = "{AQAAABAAAAAw6Dlnncbwfn5pftuT87Ka4IDamBaplbYDJFOYLCzcWxlA/5u8E2EfRAvMMMG2yu72wQXwAZGuT1ODNfQdY0ItkQ==}"

String get_branch_name(List<String> branches) {
    for (branch in branches) {
        if ("$JOB_NAME".toUpperCase().contains(branch.toUpperCase())) {
            return branch
        }
    }
    return 'develop' // domy≈õlna warto≈õƒá
}

def getProfile(String jobName) {
//    if (jobName.contains("Supportly_PullRequest")) {
//        return "postgres"
//    }
    return jobName.substring(jobName.lastIndexOf("-") + 1)
}

def getWorkspaceSuffix() {
    // env.WORKSPACE jest automatycznie ustawione przez Jenkinsa
    def ws = env.WORKSPACE
    def matcher = ws =~ /@(\d+)$/
    return matcher ? matcher[0][1] : "1"  // je≈õli brak @, zwraca "1"
}

def startContainerSafely(String containerName) {
    script {
        int maxRetries = 60
        int delaySeconds = 2      // Zwiƒôkszamy nieco czas oczekiwania
        boolean isReady = false

        echo ">>> [START] Weryfikacja i start kontenera: ${containerName}"

        // 1. Znalezienie ID kontenera
        def containerId = sh(script: "docker ps -a -q -f name=^/${containerName}\$", returnStdout: true).trim()

        if (!containerId) {
            error "Kontener '${containerName}' nie istnieje!"
        }

        // 2. Upewnienie siƒô, ≈ºe kontener dzia≈Ça (State.Running)
        def isRunning = sh(script: "docker inspect -f '{{.State.Running}}' ${containerId}", returnStdout: true).trim()
        if (isRunning != 'true') {
            echo "Kontener nie dzia≈Ça. Uruchamiam..."
            sh "docker start ${containerId}"
        }

        // 3. PƒòTLA SPRAWDZAJƒÑCA HEALTHCHECK (To jest kluczowa zmiana)
        echo "Czekam na status 'healthy'..."

        for (int i = 1; i <= maxRetries; i++) {
            // Pobieramy status zdrowia (healthy / starting / unhealthy / <puste>)
            // U≈ºywamy try/catch, bo je≈õli obraz nie ma healthchecka, komenda mo≈ºe zwr√≥ciƒá b≈ÇƒÖd lub pusty ciƒÖg
            def healthStatus = ""
            try {
                healthStatus = sh(script: "docker inspect --format='{{.State.Health.Status}}' ${containerId}", returnStdout: true).trim()
            } catch (Exception e) {
                // Je≈õli brak healthchecka, zak≈Çadamy "running" jako wystarczajƒÖce
                healthStatus = "no_healthcheck"
            }

            echo "(Pr√≥ba ${i}/${maxRetries}) Status zdrowia: [${healthStatus}]"

            if (healthStatus == 'healthy') {
                echo "SUKCES: Kontener jest w pe≈Çni gotowy do pracy!"
                isReady = true
                break
            } else if (healthStatus == 'unhealthy') {
                error "AWARIA: Kontener zg≈Çosi≈Ç status 'unhealthy'. Co≈õ posz≈Ço nie tak z aplikacjƒÖ."
            } else if (healthStatus == 'no_healthcheck') {
                echo "UWAGA: Obraz nie ma definicji Healthcheck. Zak≈Çadam, ≈ºe dzia≈Ça, bo jest 'Running'."
                isReady = true
                break
            }

            // Je≈õli jest 'starting', czekamy dalej
            sleep delaySeconds
        }

        if (!isReady) {
            echo "B≈ÅƒÑD: Timeout oczekiwania na healthcheck."
            // Logi dla diagnostyki
            sh "docker logs --tail 50 ${containerId}"
            error "Kontener ${containerName} nie osiƒÖgnƒÖ≈Ç statusu 'healthy' w przewidzianym czasie."
        }
    }
}

def dockerStop(String containerName) {
    def containerId = sh(script: "docker ps -a -q -f name=^/${containerName}\$", returnStdout: true).trim()
    if (containerId != null) {
        sh """docker stop ${containerName}"""
        echo "Docker ${containerName} zosta≈Ç wy≈ÇƒÖczony"
    }
    echo "Docker ${containerName} by≈Ç wy≈ÇƒÖczony"

}

def runSql() {
    def containerName = "${env.PROJECT_NAME}-database-${env.PROFILE}-1"

    // Tw√≥j jedyny administrator to supportly
    def dbUser = "supportly"

    def sqlPath = "conf/postgres/" // Twoja ≈õcie≈ºka

    // Ustawienie has≈Ça
    sh "export PGPASSWORD='Qwerty.1'"

    echo "--- Krok 1: RESETOWANIE BAZY (≈ÅƒÖczenie z 'template1') ---"
    // ≈ÅƒÖczymy siƒô do template1, aby m√≥c bezpiecznie usunƒÖƒá bazƒô supportly "z zewnƒÖtrz"
    sh """
        docker exec -i ${containerName} psql \
        -U ${dbUser} \
        -d template1 \
        < ${sqlPath}01_reset_db.sql
    """

    echo "--- Krok 2: TWORZENIE SCHEMATU (≈ÅƒÖczenie z nowƒÖ bazƒÖ 'supportly') ---"
    // Teraz baza ju≈º istnieje, wiƒôc wchodzimy prosto do niej
    sh """
        docker exec -i ${containerName} psql \
        -U ${dbUser} \
        -d supportly \
        < ${sqlPath}02_create_schema.sql
    """

    echo "Pomy≈õlnie wyzerowano bazƒô i utworzono schemat."
}

static boolean containsSubstring(String text, String fragment) {
    if (text == null || fragment == null) {
        return false;
    }
    return text.contains(fragment);
}

def waitForOracle(String containerName) {
    echo ">>> [START] Oczekiwanie na gotowo≈õƒá Oracle (Active SQL Check): ${containerName}"

    // Parametry po≈ÇƒÖczenia
    def dbUser = "SYSTEM"
    def dbPass = "Qwerty_1"
    def dbService = "ORCLCDB"

    timeout(time: 10, unit: 'MINUTES') {
        waitUntil {
            script {
                // ZMIANA: U≈ºywamy 'echo | docker exec -i' zamiast '<<<'
                // Flaga -i w docker exec jest konieczna, aby przyjƒÖƒá dane z potoku (pipe)
                def checkCmd = """
                    echo "SELECT 1 FROM dual;" | docker exec -i ${containerName} sqlplus -L -s ${dbUser}/${dbPass}@//localhost:1521/${dbService} > /dev/null 2>&1
                """

                // returnStatus: true sprawia, ≈ºe je≈õli komenda zwr√≥ci b≈ÇƒÖd (np. ORA-01033), to nie przerywamy pipeline'u
                int status = sh(script: checkCmd, returnStatus: true)

                if (status == 0) {
                    echo ">>> SUKCES: Baza danych jest otwarta i odpowiada na zapytania!"
                    return true // Przerywa pƒôtlƒô waitUntil
                } else {
                    // Kod b≈Çƒôdu inny ni≈º 0 oznacza, ≈ºe sqlplus nie m√≥g≈Ç siƒô po≈ÇƒÖczyƒá
                    echo ">>> Baza zajƒôta (ORA-01033 lub startowanie). Czekam 5s..."
                    sleep 5
                    return false // Powtarza pƒôtlƒô
                }
            }
        }
    }
}

def runClearScriptOracle(String containerName) {
    echo "üßπ Uruchamiam czyszczenie bazy jako SYSTEM na kontenerze ${containerName}..."

    // ZMIANA 1: Logujemy siƒô jako SYSTEM (has≈Ço to zazwyczaj to samo co ustawi≈Çe≈õ przy starcie kontenera)
    // ZMIANA 2: Dodajemy 'WHENEVER SQLERROR EXIT SQL.SQLCODE', ≈ºeby Jenkins wiedzia≈Ç o b≈Çƒôdzie
    def scriptCmd = """
    docker exec -i ${containerName} \
    sqlplus -s SYSTEM/Qwerty_1@//localhost:1521/ORCLCDB \
    <<EOF
    WHENEVER SQLERROR EXIT SQL.SQLCODE;
    @/opt/oracle/scripts/E2E/SUPPORTLY/clear.sql
    EXIT;
EOF
    """

    def scriptCmd2 = """
    docker exec -i ${containerName} \
    sqlplus -s SYSTEM/Qwerty_1@//localhost:1521/ORCLCDB \
    <<EOF
    WHENEVER SQLERROR EXIT SQL.SQLCODE;
    @/opt/oracle/scripts/E2E/SUPPORTLY/init.sql
    EXIT;
EOF
    """

    // Uruchomienie z obs≈ÇugƒÖ b≈Çƒôd√≥w
    try {
        sh scriptCmd
        sh scriptCmd2
        echo "Baza wyczyszczona pomy≈õlnie."
    } catch (Exception e) {
        error "B≈ÇƒÖd SQL podczas czyszczenia bazy! Sprawd≈∫ logi powy≈ºej."
    }
}

def runSqlMssql() {
    def containerName = "${env.PROJECT_NAME}-database-${env.PROFILE}-1"
    def user = "SA"
    def password = "Qwerty.1"

    // Sprawd≈∫ dok≈Çadnie tƒô ≈õcie≈ºkƒô w wynikach 'ls -R' poni≈ºej
    def sqlPath = "conf/mssql/config/"


    echo "--- Krok 1: CLEANUP ---"
    // Zmiana: Pr√≥bujemy u≈ºyƒá nowszej ≈õcie≈ºki tools18 LUB samej komendy sqlcmd
    // Je≈õli nadal nie dzia≈Ça, sprawd≈∫ wynik komendy 'find' z Kroku 1
    sh """
        cat ${sqlPath}cleanup.sql | docker exec -i ${containerName} \
        /opt/mssql-tools18/bin/sqlcmd \
        -S localhost \
        -U ${user} \
        -P '${password}' \
        -d master \
        -C 
    """
    // UWAGA: Doda≈Çem flagƒô -C (Trust Server Certificate), czƒôsto potrzebna w nowych wersjach SQL

    echo "--- Krok 2: SETUP ---"
    sh """
        cat ${sqlPath}setup.sql | docker exec -i ${containerName} \
        /opt/mssql-tools18/bin/sqlcmd \
        -S localhost \
        -U ${user} \
        -P '${password}' \
        -d master \
        -C
    """

    echo "Pomy≈õlnie wykonano skrypty MSSQL."
}