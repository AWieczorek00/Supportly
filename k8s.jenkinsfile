import groovy.transform.Field

@Field
final String pipelineConfig = '''
{
    "ports":{
        "app":{
            "postgres-master":1000,            
            "mssql-master":1100,           
            "oracle-master":1200            
        },
        "db":{
            "postgres-master":1010,            
            "mssql-master":1110,           
            "oracle-master":1210
        },
        "front":{
            "postgres-master":1020,            
            "mssql-master":1120,           
            "oracle-master":1220
        }
    }
}
'''

pipeline {
    agent { label 'built-in' }

    tools {
        maven 'M3'
        jdk 'JDK21'
        nodejs 'node'
    }

    environment {
        REGISTRY = '192.168.0.81:32000'
        GIT_PROJECT_NAME = 'Supportly'
        E2E_DOCKER_HOST = '192.168.0.81'
        E2E_DOCKER_HOST_URL = 'http://192.168.0.81:'
    }

    parameters {
        booleanParam(name: 'E2E_TESTS', defaultValue: true, description: 'Czy uruchomić testy E2E?')
        booleanParam(name: 'CLEANUP_DOCKER', defaultValue: true, description: 'Czy czyścić kontenery, obrazy i wolumeny Docker po testach E2E?')
        booleanParam(name: 'DEPLOY_TO_KUBE', defaultValue: false, description: 'Czy wdrożyć do MicroK8s?')
    }

    options {
        timestamps()
        timeout(time: 1, unit: 'HOURS')
        buildDiscarder(logRotator(numToKeepStr: '5'))
        disableConcurrentBuilds()
        skipDefaultCheckout()
    }
    stages {
        stage('Checkout') {
            steps {
                echo ">>>[Pobieranie najnowszych zmian]<<<"
                checkoutSources()
            }
        }

        stage('Build & Test') {
            steps {
                script {

                    parallel('Build & Test Backend': {
                        dir('supportly-backend') {
                            echo ">>>[TESTY BACKENDU]<<<"
                            sh "mvn verify -Dspring.profiles.active=${env.PROFILE} -Dmaven.test.failure.ignore=true"
                            junit 'target/surefire-reports/*.xml'
                            echo ">>>[BUDOWANIE BACKENDU]<<<"
                            sh "mvn clean package spring-boot:repackage -P${env.PROFILE} -Dspring.profiles.active=${env.PROFILE}  -DskipTests"
                        }
                    },
                            'Build & Test Frontend': {
                                dir('supportly-frontend') {
//                                    replaceInFile('http://localhost:8080', "http://${env.PROJECT_NAME}-backend-${env.PROFILE}-1:${env.PORT_BACKEND}", "src/assets/config.json")
                                    echo ">>>[BUDOWANIE FRONTENDU]<<<"
                                    sh "yes | ng version"
                                    sh script: "npm install --force", label: "npm install"
                                    sh script: "ng build --output-path=../conf/frontend/supportly-frontend", label: "ng build"
                                }
                            })

                    replaceInFile('localhost', '192.168.0.81', "conf/docker-compose-${env.PROFILE}.yml")
                    replaceInFile('PORT_DB', env.PORT_DB, "conf/docker-compose-${env.PROFILE}.yml")
                    replaceInFile('PORT_BACKEND', env.PORT_BACKEND, "conf/docker-compose-${env.PROFILE}.yml")
                    replaceInFile('latest', env.BUILDTAG, "conf/docker-compose-${env.PROFILE}.yml")
                    replaceInFile('PORT_FRONTEND', env.PORT_FRONT, "conf/docker-compose-${env.PROFILE}.yml")
//                    replaceInFile('URL_BACKEND', "${env.PROJECT_NAME}-backend-${env.PROFILE}-1/${env.PORT_BACKEND}/", "src/assets/nginx.conf")
                    replaceInFile('http://localhost:8080', "http://${env.E2E_DOCKER_HOST}:${env.PORT_BACKEND}", "conf/frontend/supportly-frontend/browser/assets/config.json")
                    replaceInFile('1009', env.PORT_DB, 'conf/backend/backend.env')
                    replaceInFile('localhost', '192.168.0.81', 'conf/backend/backend.env')
                    replaceInFile('API', "http://192.168.0.81:${env.PORT_FRONT}", 'conf/backend/backend.env')
                    replaceInFile('default', "${env.PROFILE}", 'conf/backend/Dockerfile')

                    sh "cat conf/docker-compose-${env.PROFILE}.yml"
                    sh 'cat conf/backend/backend.env'

                    stash name: 'supportly', includes: 'conf/**', useDefaultExcludes: false
                    stash name: 'supportly-e2e', includes: 'supportly-e2e/**', useDefaultExcludes: false

                }
            }
        }
        stage('Build & Push Images') {
            agent { label 'docker-agent' } // <-- TO DODAJ
            steps {
                script {
                    unstash 'supportly'

                    echo ">>> Building and pushing Docker images to local registry..."
                    dir('conf') {

                        sh "cat docker-compose-${env.PROFILE}.yml"
                        sh 'cat backend/backend.env'
                        sh 'ls frontend'
                        sh 'ls frontend/supportly-frontend/browser/assets'
                        // Buduj obrazy z tagami do rejestru
                        sh "docker compose -f docker-compose-${env.PROFILE}.yml build --no-cache"

                    }
                }
            }
        }

        stage('DeployE2E') {
            when {
                expression { params.E2E_TESTS }
            }
            agent { label 'docker-agent' }

            steps {
                script {
                    echo ">>> Deploying docker-compose on remote host ..."

                    unstash 'supportly'

                    dir('conf') {

                        echo ">>> Używam taga obrazu: ${buildTag}"

                        echo ">>> Project name dla Compose: ${env.PROJECT_NAME}"

                        echo ">>> Usuwam istniejące kontenery i sieci..."
                        sh """
                    docker compose -f docker-compose-${env.PROFILE}.yml -p ${env.PROJECT_NAME} down --remove-orphans -v || true
                """

                        echo ">>> Uruchamiam docker-compose lokalnie (na agencie)..."
                        sh """
                    docker compose -f docker-compose-${env.PROFILE}.yml -p ${env.PROJECT_NAME} up -d
                """

                        echo ">>> Sprawdzam, czy kontenery działają poprawnie..."
                        waitForContainers(["${env.PROJECT_NAME}-backend-${env.PROFILE}-1",
                                           "${env.PROJECT_NAME}-database-${env.PROFILE}-1"] as List<String>)
                    }
                }
            }
        }


        stage('E2E') {
            when {
                expression { params.E2E_TESTS }
            }
            steps {
                script {
                    echo ">>> Running Selenium E2E tests..."

                    unstash 'supportly-e2e'

                    def databaseUrl = ""

                    if(env.PROFILE=="postgres"){
                        databaseUrl = "jdbc:postgresql://192.168.0.81:${env.PORT_DB}/postgres"
                    }

                    if(env.PROFILE=="mssql"){
                        databaseUrl = """jdbc:sqlserver://192.168.0.81:${env.PORT_DB};databaseName=supportly;encrypt=false"""
                    }

                    if(env.PROFILE=="oracle"){
                        databaseUrl = "jdbc:postgresql://192.168.0.81:${env.PORT_DB}/postgres"
                    }

                    echo "${env.E2E_DOCKER_HOST_URL}${env.PORT_FRONT}"
                    echo "${databaseUrl}"


                    dir('supportly-e2e') {
                        // Jeśli testy się nie powiodą, stage będzie czerwony,
                        // ale pipeline pójdzie dalej i raporty się opublikują.
                        catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                            sh """
                        export BASE_URL=${env.E2E_DOCKER_HOST_URL}${env.PORT_FRONT}
                        export BASE_URL_DATABASE=${databaseUrl}
                        export PROFILE=${env.PROFILE}
                        mvn clean test
                    """
                        }
                    }
                }
            }
        }
        stage('Cleanup Docker') {
            when {
                expression { params.E2E_TESTS && params.CLEANUP_DOCKER }
            }
            agent { label 'docker-agent' }

            steps {
                script {
                    echo ">>> Cleanup docker containers, images and volumes"

                    unstash 'supportly'


                    echo ">>> Using project name: ${env.PROJECT_NAME} for cleanup"

                    sh """
                # Usuwamy tylko kontenery i sieci dla tego project name
                docker compose -f conf/docker-compose-${env.PROFILE}.yml -p ${env.PROJECT_NAME} down --volumes --remove-orphans
                
                # Opcjonalnie czyszczenie nieużywanych obrazów i wolumenów
                docker image prune -f
                docker volume prune -f
            """
                }
            }
        }
        stage('Deploy to kube') {
            when {
                expression { params.DEPLOY_TO_KUBE }
            }
            steps {
                dir('conf') {
                    script {
                        // Sprawdzanie gotowości API serwera MicroK8s
                        def checkHealthz = remoteMicrok8s('''
                    for i in {1..10}; do
                        echo ">>> Próba $i: sprawdzanie /healthz..."
                         microk8s kubectl get --raw=/healthz && break
                        echo ">>> API jeszcze nie gotowe, czekam 5s..."
                        sleep 5
                    done
                ''')

                        def deployCommand = """
                    echo ">>> Wdrażanie do zdalnego MicroK8s ..."
                    cat kube/k8s-deployment.yaml | ssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no jenkins@192.168.0.81 ' microk8s kubectl apply --validate=false -f -'
                """

                        def verifyDeployment = remoteMicrok8s('''
                    echo ">>> Weryfikacja wdrożenia (maks. 2 minuty)..."
                    for i in {1..24}; do
                        STATUS=$( microk8s kubectl get pods -n my-app --no-headers | awk '{print $3}' | grep -v Running | wc -l)
                        if [ "$STATUS" -eq 0 ]; then
                            echo ">>> Wszystkie pody działają poprawnie."
                             microk8s kubectl get all -n my-app
                            exit 0
                        fi
                        echo ">>> Czekam... ($i/24)"
                        sleep 5
                    done
                    echo "Nie wszystkie pody osiągnęły stan Running w ciągu 2 minut."
                     microk8s kubectl get pods -n my-app
                    exit 1
                ''')

                        sh """
                    echo ">>> Sprawdzanie gotowości MicroK8s na hoście zdalnym..."
                    ${checkHealthz}

                    ${deployCommand}

                    echo ">>> Sprawdzanie, czy wdrożenie się powiodło..."
                    ${verifyDeployment}
                """
                    }
                }
            }
        }


    }

    post {
        always {
            echo "Finished"
            junit 'supportly-e2e/target/surefire-reports/*.xml'
            echo "Build duration: ${currentBuild.durationString}"
        }
        success {
            echo "Finished success"
        }
        unstable {
            echo "Finished unstable"
        }
        failure {
            echo "Finished with error"
        }
        aborted {
            echo "Build aborted"
        }
    }
}

void replaceInFile(String pattern, String replacement, String filePath) {
    sh "sed -i 's+${pattern}+${replacement}+g' ${filePath}"
}

static def remoteMicrok8s(String command) {
    return """
        ssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no jenkins@192.168.0.81 '${command}'
    """
}

def isContainerHealthy(String containerName) {
    def status = sh(script: "docker inspect --format='{{.State.Status}}' ${containerName}", returnStdout: true).trim()
    def health = sh(script: "docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}no_healthcheck{{end}}' ${containerName}", returnStdout: true).trim()

    echo "Kontener ${containerName}: status=${status}, health=${health}"

    if (status != 'running') {
        echo "Kontener ${containerName} NIE działa (status: ${status})"
        return false
    }
    if (health != 'healthy' && health != 'no_healthcheck') {
        echo "Kontener ${containerName} ma zły stan zdrowia: ${health}"
        return false
    }
    echo "Kontener ${containerName} działa poprawnie i jest zdrowy."
    return true
}

def waitForContainers(List<String> containers, int maxWaitSeconds = 120, int intervalSeconds = 10) {
    int elapsed = 0
    while (elapsed < maxWaitSeconds) {
        echo "Sprawdzam kontenery, próba po ${elapsed} sekundach..."
        boolean allHealthy = true
        for (container in containers) {
            if (!isContainerHealthy(container)) {
                allHealthy = false
            }
        }
        if (allHealthy) {
            echo "Wszystkie kontenery działają poprawnie."
            return true
        }
        echo "Kontenery jeszcze nie są gotowe, czekam ${intervalSeconds} sekund..."
        sleep(intervalSeconds)
        elapsed += intervalSeconds
    }
    error("Nie wszystkie kontenery działały prawidłowo po ${maxWaitSeconds} sekundach!")
}

void checkoutSources() {

    // Rozpoznawanie gałęzi i profilu
    env.PIPELINE_TYPE = get_branch_name(['master', 'develop', 'PullRequest'])
    env.PROFILE = getProfile(env.JOB_NAME)

    println("Build profile: ${env.PROFILE}, branch: ${env.PIPELINE_TYPE}")
    println("JOB_NAME: ${JOB_NAME}")

    if ("PullRequest".equals(env.PIPELINE_TYPE)) {
        checkout_pull_request(env.GIT_PROJECT_NAME)
        env.MERGE_REQUEST_BUILD = true
    } else {
        checkoutRepo(env.GIT_PROJECT_NAME, env.PIPELINE_TYPE)
    }

    env.BUILDTAG = sh(script: "date +%Y%m%d-%H%M", returnStdout: true).trim()

    prepareNames(env.PIPELINE_TYPE)
}

void checkoutRepo(String project, String branch) {
    println("[checkout] ${project} -> ${branch}")

    def scmVars = checkout([$class                           : 'GitSCM',
                            branches                         : [[name: "${branch}"]],
                            doGenerateSubmoduleConfigurations: false,
                            extensions                       : [[$class: 'CloneOption', noTags: true]],
                            userRemoteConfigs                : [[credentialsId: 'Github',
                                                                 url          : "https://github.com/AWieczorek00/${project}.git"

                                                                ]]])

    env.GIT_COMMIT = scmVars.GIT_COMMIT
}

void prepareNames(String branch) {

    echo "Prepare environment variables | branch: ${branch}"


    def props = readJSON text: pipelineConfig
    def name = "${env.PROFILE}-${branch}"

    def wsSuffix = getWorkspaceSuffix()
    env.PROJECT_NAME = "supportly-${wsSuffix}"
    def projectName = "supportly-${wsSuffix}"


    env.PORT_BACKEND = props.ports.app[name]
    env.PORT_DB = props.ports.db[name]
    env.PORT_FRONT = props.ports.front[name]

    echo "PORT_BACKEND: ${env.PORT_BACKEND}"
    echo "PORT_DB: ${env.PORT_DB}"
    echo "PORT_FRONT: ${env.PORT_FRONT}"


}


def checkout_pull_request(String project) {
    echo "Pobieranie najnowszego PR z repozytorium ${project}"

    // Pobranie ostatniego otwartego PR z GitHub API
    def response = httpRequest(url: "https://api.github.com/repos/AWieczorek00/${project}/pulls?state=open&sort=updated&direction=desc&per_page=1",
            httpMode: 'GET',
            acceptType: 'APPLICATION_JSON')

    def prs = readJSON text: response.content
    if (prs.size() == 0) {
        error "Nie znaleziono żadnych otwartych PR w repozytorium ${project}"
    }

    def pr = prs[0]
    def prId = pr.number.toString()
    def sourceBranch = pr.head.ref
    def targetBranch = pr.base.ref

    echo "Checkout latest PR #${prId}: ${sourceBranch} -> ${targetBranch}"

    // Fetch i checkout brancha PR
    checkout([$class           : 'GitSCM',
              branches         : [[name: "refs/remotes/origin/${sourceBranch}"]],
              extensions       : [[$class: 'CloneOption', noTags: true]],
              userRemoteConfigs: [[url          : "https://github.com/AWieczorek00/${project}.git",
                                   credentialsId: 'Github',
                                   refspec      : "+refs/heads/${sourceBranch}:refs/remotes/origin/${sourceBranch}"]]])

    // Merge do branch docelowego
    sh """
        git fetch origin ${targetBranch}:${targetBranch}
        git merge ${targetBranch} --no-ff -m "Merge ${targetBranch} into ${sourceBranch}"
    """
}


String get_branch_name(List<String> branches) {
    for (branch in branches) {
        if ("$JOB_NAME".toUpperCase().contains(branch.toUpperCase())) {
            return branch
        }
    }
    return 'develop' // domyślna wartość
}

def getProfile(String jobName) {
    return jobName.substring(jobName.lastIndexOf("-") + 1)
}

def getWorkspaceSuffix() {
    // env.WORKSPACE jest automatycznie ustawione przez Jenkinsa
    def ws = env.WORKSPACE
    def matcher = ws =~ /@(\d+)$/
    return matcher ? matcher[0][1] : "1"  // jeśli brak @, zwraca "1"
}