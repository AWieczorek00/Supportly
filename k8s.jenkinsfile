import groovy.transform.Field

@Field
final String pipelineConfig = '''
{
    "ports":{
        "app":{
            "postgres-master":1000,            
            "postgres-master-1":1000,            
            "postgres-master-2":1001,            
            "postgres-master-3":1002,            
            "postgres-master-4":1003,            
            "postgres-master-5":1004,            
            "postgres-master-6":1005,            
            "postgres_lt-master":1001,            
            "mssql-master":1100,           
            "mssql-master-1":1100,           
            "mssql-master-2":1101,           
            "mssql-master-3":1102,           
            "mssql-master-4":1103,           
            "mssql-master-5":1104,           
            "mssql-master-6":1105,           
            "mssql_lt-master":1101,           
            "oracle-master":1200,            
            "oracle-master-1":1200,            
            "oracle-master-2":1201,            
            "oracle-master-3":1202,            
            "oracle-master-4":1203,            
            "oracle-master-5":1204,            
            "oracle-master-6":1205,            
            "oracle_lt-master":1201            
        },
        "db":{
            "postgres-master":1010,            
            "postgres-master-1":1010,            
            "postgres-master-2":1011,
            "postgres-master-3":1012,            
            "postgres-master-4":1013,            
            "postgres-master-5":1014,            
            "postgres-master-6":1015,            
            "postgres_lt-master":1011,            
            "mssql-master":1110,
            "mssql-master-1":1110,           
            "mssql-master-2":1111,           
            "mssql-master-3":1112,           
            "mssql-master-4":1113,           
            "mssql-master-5":1114,           
            "mssql-master-6":1115,           
            "mssql_lt-master":1111,           
            "oracle-master":1210,
            "oracle-master-1":1210,            
            "oracle-master-2":1211,            
            "oracle-master-3":1212,            
            "oracle-master-4":1213,            
            "oracle-master-5":1214,            
            "oracle-master-6":1215,
            "oracle_lt-master":1211
        },
        "front":{
            "postgres-master":1020,            
            "postgres-master-1":1020,            
            "postgres-master-2":1021,
            "postgres-master-3":1022,            
            "postgres-master-4":1023,            
            "postgres-master-5":1024,            
            "postgres-master-6":1025,            
            "postgres_lt-master":1021,            
            "mssql-master":1120,
            "mssql-master-1":1120,           
            "mssql-master-2":1121,           
            "mssql-master-3":1122,           
            "mssql-master-4":1123,           
            "mssql-master-5":1124,           
            "mssql-master-6":1125,           
            "mssql_lt-master":1121,           
            "oracle-master":1220,
            "oracle-master-1":1220,            
            "oracle-master-2":1221,            
            "oracle-master-3":1222,            
            "oracle-master-4":1223,            
            "oracle-master-5":1224,            
            "oracle-master-6":1225,
            "oracle_lt-master":1221
        }
    }
}
'''

pipeline {
    agent { label 'built-in' }

    tools {
        maven 'M3'
        jdk 'JDK21'
        nodejs 'node'
    }

    environment {
        REGISTRY = '192.168.0.81:32000'
        GIT_PROJECT_NAME = 'Supportly'
        E2E_DOCKER_HOST = '192.168.0.81'
        E2E_DOCKER_HOST_URL = 'http://192.168.0.81:'
    }

    parameters {
        booleanParam(name: 'E2E_TESTS', defaultValue: true, description: 'Czy stworzy dockery?')
        booleanParam(name: 'E2E_TESTS_RUN', defaultValue: false, description: 'Czy uruchomi testy E2E?')
        booleanParam(name: 'CLEANUP_DOCKER', defaultValue: true, description: 'Czy czyci kontenery, obrazy i wolumeny Docker po testach E2E?')
        booleanParam(name: 'DEPLOY_TO_KUBE', defaultValue: false, description: 'Czy wdro偶y do MicroK8s?')
        string(name: 'NUMER_PROBY', defaultValue: '1', description: 'Wpisz numer pr贸by')
    }



    options {
        timestamps()
        timeout(time: 5, unit: 'HOURS')
        buildDiscarder(logRotator(numToKeepStr: '30'))
        throttleJobProperty(
                categories: [],
                limitOneJobWithMatchingParams: false,
                maxConcurrentPerNode: 6,
                maxConcurrentTotal: 6,
                paramsToUseForLimit: '',
                throttleEnabled: true,
                throttleOption: 'project'
        )
        skipDefaultCheckout()
    }
    stages {
        stage('Checkout') {
            steps {
                echo ">>>[Pobieranie najnowszych zmian]<<<"
                checkoutSources()
            }
        }
        stage('Build & Test') {
            steps {
                script {

                    parallel('Build & Test Backend': {
                        dir('supportly-backend') {
                            echo ">>>[TESTY BACKENDU]<<<"
                            sh "mvn verify -Dspring.profiles.active=${env.PROFILE.replace('_lt', '')} -Dmaven.test.failure.ignore=true"
                            junit 'target/surefire-reports/*.xml'
                            echo ">>>[BUDOWANIE BACKENDU]<<<"
                            sh "mvn clean package spring-boot:repackage -P${env.PROFILE.replace('_lt', '')} -Dspring.profiles.active=${env.PROFILE.replace('_lt', '')}  -DskipTests"
                        }
                    },
                            'Build & Test Frontend': {
                                dir('supportly-frontend') {
                                    echo ">>>[BUDOWANIE FRONTENDU]<<<"
                                    sh "yes | ng version"
                                    sh script: "npm install --force", label: "npm install"
                                    sh script: "ng build --output-path=../conf/frontend/supportly-frontend", label: "ng build"
                                }
                            }
                    )

                    replaceInFile('PORT_DB', env.PORT_DB, "conf/docker-compose-${env.PROFILE}.yml")
                    replaceInFile('PORT_BACKEND', env.PORT_BACKEND, "conf/docker-compose-${env.PROFILE}.yml")
                    replaceInFile('latest', env.BUILDTAG, "conf/docker-compose-${env.PROFILE}.yml")
                    replaceInFile('latest', env.BUILDTAG, "conf/kube/k8s-deployment.yaml")
                    replaceInFile('PORT_FRONTEND', env.PORT_FRONT, "conf/docker-compose-${env.PROFILE}.yml")
                    replaceInFile('http://localhost:8080', "http://${env.E2E_DOCKER_HOST}:${env.PORT_BACKEND}", "conf/frontend/supportly-frontend/browser/assets/config.json")
                    replaceInFile('1009', env.PORT_DB, 'conf/backend/backend.env')
                    replaceInFile('localhost', '192.168.0.81', 'conf/backend/backend.env')
                    replaceInFile('API', "http://192.168.0.81:${env.PORT_FRONT}", 'conf/backend/backend.env')
                    replaceInFile('default', "${env.PROFILE.replace('_lt', '')}", 'conf/backend/Dockerfile')

                    sh "cat conf/docker-compose-${env.PROFILE}.yml"
                    sh 'cat conf/backend/backend.env'

                    stash name: 'supportly', includes: 'conf/**', useDefaultExcludes: false
                    stash name: 'supportly-e2e', includes: 'supportly-e2e/**', useDefaultExcludes: false

                }
            }
        }
        stage('Build & Push Images') {
            when {
                expression { params.E2E_TESTS }
            }
            agent { label 'docker-agent' }
            steps {
                script {
                    unstash 'supportly'

                    echo ">>> Building and pushing Docker images to local registry..."
                    dir('conf') {

                        sh "cat docker-compose-${env.PROFILE}.yml"
                        // ... (reszta Twoich debug贸w) ...

                        // 1. ZBUDUJ (To masz) - tworzy "ciasto" na dysku
                        sh "docker compose -f docker-compose-${env.PROFILE}.yml build --no-cache"
                        if (params.DEPLOY_TO_KUBE) {
                            // 2. WYLIJ (Tego brakowao!) - wysya "ciasto" do sklepu (Rejestru 192.168.0.81)
                            sh "docker compose -f docker-compose-${env.PROFILE}.yml push"
                        }
                    }
                }
            }
        }

        stage('DeployE2E') {
            when {
                expression { params.E2E_TESTS }
            }
            agent { label 'docker-agent' }

            steps {
                script {
                    echo ">>> Deploying docker-compose on remote host ..."

                    unstash 'supportly'
                    if (containsSubstring(env.PROFILE, "_lt")) {
                        dockerStop("${env.PROJECT_NAME}-database-${env.PROFILE}-1")

                        startContainerSafely("${env.PROJECT_NAME}-database-${env.PROFILE}-1")
                        if (env.PROFILE == "postgres_lt") {
                            runSql()
                        }

                        if (env.PROFILE == "mssql_lt") {
                            runSqlMssql()
                        }

                        if (env.PROFILE == "oracle_lt") {
                            waitForOracle("${env.PROJECT_NAME}-database-${env.PROFILE}-1")

                            runClearScriptOracle("${env.PROJECT_NAME}-database-${env.PROFILE}-1")

                        }

//                        waitForOracle("${env.PROJECT_NAME}-database-${env.PROFILE}-1")
                    }

                    dir('conf') {

                        echo ">>> U偶ywam taga obrazu: ${buildTag}"

                        echo ">>> Project name dla Compose: ${env.PROJECT_NAME}"

                        echo ">>> Usuwam istniejce kontenery i sieci..."
                        sh """
                        docker compose -f docker-compose-${env.PROFILE}.yml -p ${env.PROJECT_NAME} down --remove-orphans  -v || true
                        """
//                        docker compose -f docker-compose-${env.PROFILE}.yml -p ${env.PROJECT_NAME} down --remove-orphans -v || true

                        echo ">>> Uruchamiam docker-compose lokalnie (na agencie)..."
                        sh """
                        docker compose -f docker-compose-${env.PROFILE}.yml -p ${env.PROJECT_NAME} up -d
                            """

                        echo ">>> Sprawdzam, czy kontenery dziaaj poprawnie..."
                        waitForContainers(["${env.PROJECT_NAME}-backend-${env.PROFILE}-1",
                                           "${env.PROJECT_NAME}-database-${env.PROFILE}-1"] as List<String>)

                    }
                }
            }
        }


        stage('E2E') {
            when {
                expression { params.E2E_TESTS && params.E2E_TESTS_RUN }
            }
            steps {
                script {
                    echo ">>> Running Selenium E2E tests..."
                    unstash 'supportly-e2e'

                    // --- Logika bazy danych (bez zmian) ---
                    def databaseUrl = ""
                    if (env.PROFILE.replace('_lt', '') == "postgres") {
                        databaseUrl = "jdbc:postgresql://192.168.0.81:${env.PORT_DB}/postgres"
                    } else if (env.PROFILE.replace('_lt', '') == "mssql") {
                        databaseUrl = """jdbc:sqlserver://192.168.0.81:${env.PORT_DB};databaseName=supportly;encrypt=false"""
                    } else if (env.PROFILE.replace('_lt', '') == "oracle") {
                        databaseUrl = "jdbc:postgresql://192.168.0.81:${env.PORT_DB}/postgres"
                    }

                    def e2eEnvVars = """
                export BASE_URL=${env.E2E_DOCKER_HOST_URL}${env.PORT_FRONT}
                export BASE_URL_DATABASE=${databaseUrl}
                export PROFILE=${env.PROFILE}
            """

                    dir('supportly-e2e') {
                        // Czycimy g贸wny katalog przed kompilacj
                        sh "mvn clean test-compile -DskipTests"
                    }

                    catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                        parallel(
                                "E2E Group 1": {
                                    // POPRAWKA: Najpierw usuwamy stary folder (rm -rf), potem tworzymy nowy.
                                    // To gwarantuje, 偶e nie ma tam starych raport贸w XML.
                                    sh "rm -rf e2e_work_1 && mkdir -p e2e_work_1 && cp -r supportly-e2e/* e2e_work_1/"

                                    dir("e2e_work_1") {
                                        echo "Start: Agreement, Employee"
                                        sh """
                                ${e2eEnvVars}
                                mvn surefire:test -Dtest=AgreementTest,EmployeeTest,LoginTest,TaskTest,OrderTest -Dmaven.test.failure.ignore=true
                            """
                                    }
                                },
                                "E2E Group 2": {
                                    // POPRAWKA: To samo dla grupy 2 - czyszczenie przed kopiowaniem.
                                    sh "rm -rf e2e_work_2 && mkdir -p e2e_work_2 && cp -r supportly-e2e/* e2e_work_2/"

                                    dir("e2e_work_2") {
                                        echo "Start: HomePage, Login, Task"
                                        sh """
                                ${e2eEnvVars}
                                mvn surefire:test -Dtest=HomePageTest -Dmaven.test.failure.ignore=true
                            """
                                    }
                                }
                        )
                    }

                    // Raportowanie
                    junit 'e2e_work_*/target/surefire-reports/*.xml'
                }
            }
        }
        stage('Cleanup Docker') {
            when {
                expression { params.E2E_TESTS && params.CLEANUP_DOCKER }
            }
            agent { label 'docker-agent' }

            steps {
                script {
                    echo ">>> Cleanup docker containers, images and volumes"

                    unstash 'supportly'


                    echo ">>> Using project name: ${env.PROJECT_NAME} for cleanup"

                    if (containsSubstring(env.PROFILE, "_lt")) {
                        dockerStop("${env.PROJECT_NAME}-database-${env.PROFILE}-1")
                    }

                    sh """
                # Usuwamy tylko kontenery i sieci dla tego project name
                docker compose -f conf/docker-compose-${env.PROFILE}.yml -p ${env.PROJECT_NAME}  down --volumes 

                # Opcjonalnie czyszczenie nieu偶ywanych obraz贸w i wolumen贸w
                docker image prune -f
                docker volume prune -f
            """
                }
            }
        }
        stage('Deploy to kube') {
            when {
                expression { params.DEPLOY_TO_KUBE }
            }
            steps {
                dir('conf') {
                    script {
                        // --- KROK 1: Check Healthz (Przeniesione do Groovy) ---
                        echo ">>> [KROK 1] Sprawdzanie gotowoci API MicroK8s..."
                        int maxHealthRetries = 10
                        boolean apiReady = false

                        for (int i = 1; i <= maxHealthRetries; i++) {
                            // returnStatus: true sprawia, 偶e sh nie wywali bdu pipeline'u, tylko zwr贸ci kod wyjcia (0 = OK, inne = bd)
                            // Wysyamy prost komend bez ptli i bez 'break'
                            int exitCode = sh(script: remoteMicrok8s("microk8s kubectl get --raw=/healthz"), returnStatus: true)

                            if (exitCode == 0) {
                                echo ">>> (Pr贸ba ${i}/${maxHealthRetries}) API jest gotowe!"
                                apiReady = true
                                break
                            } else {
                                echo ">>> (Pr贸ba ${i}/${maxHealthRetries}) API nie odpowiada, czekam 5s..."
                                sleep 5
                            }
                        }

                        if (!apiReady) {
                            error "BD: API MicroK8s nie wstao po ${maxHealthRetries} pr贸bach."
                        }

                        // --- KROK 2: Deploy ---
                        echo ">>> [KROK 2] Wdra偶anie manifest贸w..."
                        // Tutaj wysyamy jedn, konkretn komend
                        def deployCmd = "cat kube/k8s-deployment.yaml | ssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no jenkins@192.168.0.81 'microk8s kubectl apply --validate=false -f -'"
                        sh deployCmd

                        // --- KROK 3: Weryfikacja (Logika Groovy) ---
                        echo ">>> [KROK 3] Weryfikacja statusu pod贸w..."

                        int maxPodRetries = 60
                        int podDelay = 5
                        boolean podsReady = false

                        for (int i = 1; i <= maxPodRetries; i++) {
                            // Wersja BEZ tr/cut - najbardziej niezawodna przez SSH
                            // Zwraca pene linie pod贸w, kt贸re nie s gotowe (np. "backend 0/1 Error ...")
                            def checkCmdString = remoteMicrok8s("microk8s kubectl get pods -n my-app --no-headers | grep -v '1/1' || true")

                            def notReadyPods = sh(script: checkCmdString, returnStdout: true).trim()

                            if (notReadyPods.isEmpty()) {
                                echo ">>> (Pr贸ba ${i}/${maxPodRetries}) SUKCES: Wszystkie pody s Ready (1/1)."
                                podsReady = true
                                break
                            } else {
                                // Teraz w logach zobaczysz peny status, co pomo偶e zrozumie dlaczego pod nie wstaje
                                echo ">>> (Pr贸ba ${i}/${maxPodRetries}) Pody jeszcze nie gotowe:\n${notReadyPods}"
                                sleep podDelay
                            }
                        }

                        if (!podsReady) {
                            echo "BD: Timeout weryfikacji pod贸w."
                            def debugInfo = sh(script: remoteMicrok8s("microk8s kubectl describe pods -n my-app"), returnStdout: true)
                            echo ">>> DEBUG INFO:\n${debugInfo}"
                            error "Wdro偶enie nieudane: pody nie wstay w zadanym czasie."
                        }
                    }
                }
            }
        }


    }

    post {
        always {
            echo "Finished"
            script {
                // Bezpieczna konwersja na boolean i sprawdzenie warunku
                if (params.E2E_TESTS_RUN.toBoolean()) {
                    // Zmieniona cie偶ka, aby apaa wyniki z folder贸w tymczasowych
//                    junit 'supportly-e2e/target/surefire-reports/*.xml'
//                    junit 'e2e_work_*/target/surefire-reports/*.xml'

                }
            }
            echo "Build duration: ${currentBuild.durationString}"
        }
        success {
            echo "Finished success"
        }
        unstable {
            echo "Finished unstable"
        }
        failure {
            echo "Finished with error"
        }
        aborted {
            echo "Build aborted"
        }
    }
}

void replaceInFile(String pattern, String replacement, String filePath) {
    sh "sed -i 's+${pattern}+${replacement}+g' ${filePath}"
}

static def remoteMicrok8s(String command) {
    return """
        ssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no jenkins@192.168.0.81 '${command}'
    """
}

def isContainerHealthy(String containerName) {
    def status = sh(script: "docker inspect --format='{{.State.Status}}' ${containerName}", returnStdout: true).trim()
    def health = sh(script: "docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}no_healthcheck{{end}}' ${containerName}", returnStdout: true).trim()

    echo "Kontener ${containerName}: status=${status}, health=${health}"

    if (status != 'running') {
        echo "Kontener ${containerName} NIE dziaa (status: ${status})"
        return false
    }
    if (health != 'healthy' && health != 'no_healthcheck') {
        echo "Kontener ${containerName} ma zy stan zdrowia: ${health}"
        return false
    }
    echo "Kontener ${containerName} dziaa poprawnie i jest zdrowy."
    return true
}

def waitForContainers(List<String> containers, int maxWaitSeconds = 120, int intervalSeconds = 10) {
    int elapsed = 0
    while (elapsed < maxWaitSeconds) {
        echo "Sprawdzam kontenery, pr贸ba po ${elapsed} sekundach..."
        boolean allHealthy = true
        for (container in containers) {
            if (!isContainerHealthy(container)) {
                allHealthy = false
            }
        }
        if (allHealthy) {
            echo "Wszystkie kontenery dziaaj poprawnie."
            return true
        }
        echo "Kontenery jeszcze nie s gotowe, czekam ${intervalSeconds} sekund..."
        sleep(intervalSeconds)
        elapsed += intervalSeconds
    }
    error("Nie wszystkie kontenery dziaay prawidowo po ${maxWaitSeconds} sekundach!")
}

void checkoutSources() {

    // Rozpoznawanie gazi i profilu
    env.PIPELINE_TYPE = get_branch_name(['master', 'develop', 'PullRequest'])
    env.LT = false
    env.PROFILE = getProfile(env.JOB_NAME)

    println("Build profile: ${env.PROFILE}, branch: ${env.PIPELINE_TYPE}")
    println("JOB_NAME: ${JOB_NAME}")

    if ("PullRequest".equals(env.PIPELINE_TYPE)) {
        checkout_pull_request(env.GIT_PROJECT_NAME)
        env.MERGE_REQUEST_BUILD = true
    } else {
        checkoutRepo(env.GIT_PROJECT_NAME, env.PIPELINE_TYPE)
    }

    env.BUILDTAG = sh(script: "date +%Y%m%d-%H%M", returnStdout: true).trim()

    prepareNames(env.PIPELINE_TYPE)
}

void checkoutRepo(String project, String branch) {
    println("[checkout] ${project} -> ${branch}")

    def scmVars = checkout([$class                           : 'GitSCM',
                            branches                         : [[name: "${branch}"]],
                            doGenerateSubmoduleConfigurations: false,
                            extensions                       : [[$class: 'CloneOption', noTags: true]],
                            userRemoteConfigs                : [[credentialsId: 'Github',
                                                                 url          : "https://github.com/AWieczorek00/${project}.git"

                                                                ]]])

    env.GIT_COMMIT = scmVars.GIT_COMMIT
}

void prepareNames(String branch) {

    echo "Prepare environment variables | branch: ${branch}"

    def wsSuffix = getWorkspaceSuffix()
    def props = readJSON text: pipelineConfig
    def name = "${env.PROFILE}-${branch}-${wsSuffix}"
    echo "Nazwa proffilu parametru ${name}"

    env.PROJECT_NAME = "supportly-${wsSuffix}"
    def projectName = "supportly-${wsSuffix}"


    env.PORT_BACKEND = props.ports.app[name]
    env.PORT_DB = props.ports.db[name]
    env.PORT_FRONT = props.ports.front[name]

    echo "PORT_BACKEND: ${env.PORT_BACKEND}"
    echo "PORT_DB: ${env.PORT_DB}"
    echo "PORT_FRONT: ${env.PORT_FRONT}"


}


def checkout_pull_request(String project) {
    echo "Pobieranie najnowszego PR z repozytorium ${project}"

    // Pobranie ostatniego otwartego PR z GitHub API
    def response = httpRequest(url: "https://api.github.com/repos/AWieczorek00/${project}/pulls?state=open&sort=updated&direction=desc&per_page=1",
            httpMode: 'GET',
            acceptType: 'APPLICATION_JSON')

    def prs = readJSON text: response.content
    if (prs.size() == 0) {
        error "Nie znaleziono 偶adnych otwartych PR w repozytorium ${project}"
    }

    def pr = prs[0]
    def prId = pr.number.toString()
    def sourceBranch = pr.head.ref
    def targetBranch = pr.base.ref

    echo "Checkout latest PR #${prId}: ${sourceBranch} -> ${targetBranch}"

    // Fetch i checkout brancha PR
    checkout([$class           : 'GitSCM',
              branches         : [[name: "refs/remotes/origin/${sourceBranch}"]],
              extensions       : [[$class: 'CloneOption', noTags: true]],
              userRemoteConfigs: [[url          : "https://github.com/AWieczorek00/${project}.git",
                                   credentialsId: 'Github',
                                   refspec      : "+refs/heads/${sourceBranch}:refs/remotes/origin/${sourceBranch}"]]])

    // Merge do branch docelowego
    sh """
        git fetch origin ${targetBranch}:${targetBranch}
        git merge ${targetBranch} --no-ff -m "Merge ${targetBranch} into ${sourceBranch}"
    """
}

value = "{AQAAABAAAAAw6Dlnncbwfn5pftuT87Ka4IDamBaplbYDJFOYLCzcWxlA/5u8E2EfRAvMMMG2yu72wQXwAZGuT1ODNfQdY0ItkQ==}"

String get_branch_name(List<String> branches) {
    for (branch in branches) {
        if ("$JOB_NAME".toUpperCase().contains(branch.toUpperCase())) {
            return branch
        }
    }
    return 'develop' // domylna warto
}

def getProfile(String jobName) {
//    if (jobName.contains("Supportly_PullRequest")) {
//        return "postgres"
//    }
    return jobName.substring(jobName.lastIndexOf("-") + 1)
}

def getWorkspaceSuffix() {
    // env.WORKSPACE jest automatycznie ustawione przez Jenkinsa
    def ws = env.WORKSPACE
    def matcher = ws =~ /@(\d+)$/
    return matcher ? matcher[0][1] : "1"  // jeli brak @, zwraca "1"
}

def startContainerSafely(String containerName) {
    script {
        int maxRetries = 60
        int delaySeconds = 2      // Zwikszamy nieco czas oczekiwania
        boolean isReady = false

        echo ">>> [START] Weryfikacja i start kontenera: ${containerName}"

        // 1. Znalezienie ID kontenera
        def containerId = sh(script: "docker ps -a -q -f name=^/${containerName}\$", returnStdout: true).trim()

        if (!containerId) {
            error "Kontener '${containerName}' nie istnieje!"
        }

        // 2. Upewnienie si, 偶e kontener dziaa (State.Running)
        def isRunning = sh(script: "docker inspect -f '{{.State.Running}}' ${containerId}", returnStdout: true).trim()
        if (isRunning != 'true') {
            echo "Kontener nie dziaa. Uruchamiam..."
            sh "docker start ${containerId}"
        }

        // 3. PTLA SPRAWDZAJCA HEALTHCHECK (To jest kluczowa zmiana)
        echo "Czekam na status 'healthy'..."

        for (int i = 1; i <= maxRetries; i++) {
            // Pobieramy status zdrowia (healthy / starting / unhealthy / <puste>)
            // U偶ywamy try/catch, bo jeli obraz nie ma healthchecka, komenda mo偶e zwr贸ci bd lub pusty cig
            def healthStatus = ""
            try {
                healthStatus = sh(script: "docker inspect --format='{{.State.Health.Status}}' ${containerId}", returnStdout: true).trim()
            } catch (Exception e) {
                // Jeli brak healthchecka, zakadamy "running" jako wystarczajce
                healthStatus = "no_healthcheck"
            }

            echo "(Pr贸ba ${i}/${maxRetries}) Status zdrowia: [${healthStatus}]"

            if (healthStatus == 'healthy') {
                echo "SUKCES: Kontener jest w peni gotowy do pracy!"
                isReady = true
                break
            } else if (healthStatus == 'unhealthy') {
                error "AWARIA: Kontener zgosi status 'unhealthy'. Co poszo nie tak z aplikacj."
            } else if (healthStatus == 'no_healthcheck') {
                echo "UWAGA: Obraz nie ma definicji Healthcheck. Zakadam, 偶e dziaa, bo jest 'Running'."
                isReady = true
                break
            }

            // Jeli jest 'starting', czekamy dalej
            sleep delaySeconds
        }

        if (!isReady) {
            echo "BD: Timeout oczekiwania na healthcheck."
            // Logi dla diagnostyki
            sh "docker logs --tail 50 ${containerId}"
            error "Kontener ${containerName} nie osign statusu 'healthy' w przewidzianym czasie."
        }
    }
}

def dockerStop(String containerName) {
    def containerId = sh(script: "docker ps -a -q -f name=^/${containerName}\$", returnStdout: true).trim()
    if (containerId != null) {
        sh """docker stop ${containerName}"""
        echo "Docker ${containerName} zosta wyczony"
    }
    echo "Docker ${containerName} by wyczony"

}

def runSql() {
    def containerName = "${env.PROJECT_NAME}-database-${env.PROFILE}-1"

    // Tw贸j jedyny administrator to supportly
    def dbUser = "supportly"

    def sqlPath = "conf/postgres/" // Twoja cie偶ka

    // Ustawienie hasa
    sh "export PGPASSWORD='Qwerty.1'"

    echo "--- Krok 1: RESETOWANIE BAZY (czenie z 'template1') ---"
    // czymy si do template1, aby m贸c bezpiecznie usun baz supportly "z zewntrz"
    sh """
        docker exec -i ${containerName} psql \
        -U ${dbUser} \
        -d template1 \
        < ${sqlPath}01_reset_db.sql
    """

    echo "--- Krok 2: TWORZENIE SCHEMATU (czenie z now baz 'supportly') ---"
    // Teraz baza ju偶 istnieje, wic wchodzimy prosto do niej
    sh """
        docker exec -i ${containerName} psql \
        -U ${dbUser} \
        -d supportly \
        < ${sqlPath}02_create_schema.sql
    """

    echo "Pomylnie wyzerowano baz i utworzono schemat."
}

static boolean containsSubstring(String text, String fragment) {
    if (text == null || fragment == null) {
        return false;
    }
    return text.contains(fragment);
}

def waitForOracle(String containerName) {
    echo ">>> [START] Oczekiwanie na gotowo Oracle (Active SQL Check): ${containerName}"

    // Parametry poczenia
    def dbUser = "SYSTEM"
    def dbPass = "Qwerty_1"
    def dbService = "ORCLCDB"

    timeout(time: 10, unit: 'MINUTES') {
        waitUntil {
            script {
                // ZMIANA: U偶ywamy 'echo | docker exec -i' zamiast '<<<'
                // Flaga -i w docker exec jest konieczna, aby przyj dane z potoku (pipe)
                def checkCmd = """
                    echo "SELECT 1 FROM dual;" | docker exec -i ${containerName} sqlplus -L -s ${dbUser}/${dbPass}@//localhost:1521/${dbService} > /dev/null 2>&1
                """

                // returnStatus: true sprawia, 偶e jeli komenda zwr贸ci bd (np. ORA-01033), to nie przerywamy pipeline'u
                int status = sh(script: checkCmd, returnStatus: true)

                if (status == 0) {
                    echo ">>> SUKCES: Baza danych jest otwarta i odpowiada na zapytania!"
                    return true // Przerywa ptl waitUntil
                } else {
                    // Kod bdu inny ni偶 0 oznacza, 偶e sqlplus nie m贸g si poczy
                    echo ">>> Baza zajta (ORA-01033 lub startowanie). Czekam 5s..."
                    sleep 5
                    return false // Powtarza ptl
                }
            }
        }
    }
}

def runClearScriptOracle(String containerName) {
    echo "Ч Uruchamiam czyszczenie bazy jako SYSTEM na kontenerze ${containerName}..."

    // ZMIANA 1: Logujemy si jako SYSTEM (haso to zazwyczaj to samo co ustawie przy starcie kontenera)
    // ZMIANA 2: Dodajemy 'WHENEVER SQLERROR EXIT SQL.SQLCODE', 偶eby Jenkins wiedzia o bdzie
    def scriptCmd = """
    docker exec -i ${containerName} \
    sqlplus -s SYSTEM/Qwerty_1@//localhost:1521/ORCLCDB \
    <<EOF
    WHENEVER SQLERROR EXIT SQL.SQLCODE;
    @/opt/oracle/scripts/E2E/SUPPORTLY/clear.sql
    EXIT;
EOF
    """

    def scriptCmd2 = """
    docker exec -i ${containerName} \
    sqlplus -s SYSTEM/Qwerty_1@//localhost:1521/ORCLCDB \
    <<EOF
    WHENEVER SQLERROR EXIT SQL.SQLCODE;
    @/opt/oracle/scripts/E2E/SUPPORTLY/init.sql
    EXIT;
EOF
    """

    // Uruchomienie z obsug bd贸w
    try {
        sh scriptCmd
        sh scriptCmd2
        echo "Baza wyczyszczona pomylnie."
    } catch (Exception e) {
        error "Bd SQL podczas czyszczenia bazy! Sprawd藕 logi powy偶ej."
    }
}

def runSqlMssql() {
    def containerName = "${env.PROJECT_NAME}-database-${env.PROFILE}-1"
    def user = "SA"
    def password = "Qwerty.1"

    // Sprawd藕 dokadnie t cie偶k w wynikach 'ls -R' poni偶ej
    def sqlPath = "conf/mssql/config/"


    echo "--- Krok 1: CLEANUP ---"
    // Zmiana: Pr贸bujemy u偶y nowszej cie偶ki tools18 LUB samej komendy sqlcmd
    // Jeli nadal nie dziaa, sprawd藕 wynik komendy 'find' z Kroku 1
    sh """
        cat ${sqlPath}cleanup.sql | docker exec -i ${containerName} \
        /opt/mssql-tools18/bin/sqlcmd \
        -S localhost \
        -U ${user} \
        -P '${password}' \
        -d master \
        -C 
    """
    // UWAGA: Dodaem flag -C (Trust Server Certificate), czsto potrzebna w nowych wersjach SQL

    echo "--- Krok 2: SETUP ---"
    sh """
        cat ${sqlPath}setup.sql | docker exec -i ${containerName} \
        /opt/mssql-tools18/bin/sqlcmd \
        -S localhost \
        -U ${user} \
        -P '${password}' \
        -d master \
        -C
    """

    echo "Pomylnie wykonano skrypty MSSQL."
}